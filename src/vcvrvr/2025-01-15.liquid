---
title: sending pixels over the wire
page_title: "sending pixels over the wire [gtnoblg/vcvrvr]"
date: 2025-01-15

truncate: true
preview_text: Toward an ideal state.
preview_img_src: src/img/vcvrvr/chunked_send.jpg 
preview_img_alt: a flow diagram showing a strategy for sending data in chunks over a UDP connection 
---
<p>Previously, I realized I could let Rack handle texture rendering, since Rack is already rendering textures. This is what we in the industry call an &ldquo;omg duh wtf why didn&rsquo;t i realize&rdquo; moment. What this means is that I might be able to get away with not requiring a custom version of Rack. If I continue to extrapolate from there, I can see that there would no longer be a need to manage that custom Rack build for the user. That means that the VR frontend and Rack don&rsquo;t necessarily need to be running on the same machine. And if that was the case, they wouldn&rsquo;t have a shared filesystem to use to pass texture data from Rack to Unreal. What would that look like?</p>
<p>There are still a couple of potential roadblocks to ditching the custom Rack build, but I&rsquo;m curious now and I want to take a little detour and try to send the pixels over the network. Luckily this is just a silly side project and I&rsquo;m the boss here, so that&rsquo;s exactly what I&rsquo;ll do.</p>
<p>I want to stick with OSC to send the data for now, since that&rsquo;s what I&rsquo;ve been using up to now for all the other communications and it seems like a fun challenge. OSC has a data type called <tt>blob</tt>, which is just an array of unsigned 8-bit integers. We&rsquo;re working with a theoretical maximum packet size of around 64 kilobytes, but because of the reality of networking technology, the actual maximum size if we&rsquo;re sending over a network is more like <a href="https://blog.apnic.net/2024/10/08/the-size-of-the-packet/#:~:text=The%20pragmatic%20default,this%20size%20range.">1500 bytes</a>, or, more pessimistically, <a href="https://io7m.com/documents/udp-reliable/#:~:text=However%2C%20this%20value,IPv6%2Dlayer%20fragmentation.">1232 bytes</a>. And that&rsquo;s assuming ipv6. Right now, a rendered panel is an array of uncompressed RGBA pixel data, always exactly 4 bytes per pixel. A small panel is around 1 megabyte of data. So I&rsquo;ll have to break that data up into chunks in order to send it in a bunch of packets.</p>
<p>Because OSC uses UDP, it is stateless. Fire and forget. Send your data into the ether and hope for the best. There&rsquo;s nothing about the protocol that confirms the packets arrived at all. There&rsquo;s no guarantee that they&rsquo;ll arrive in the same order in which they were sent. But we need to rebuild the image on the other side. We&rsquo;ll need to know the order, and we&rsquo;ll need every chunk.</p>
<p>So that&rsquo;s the problem defined.</p>
<p>I wanted to see what I could come up with on my own before looking into other folks&rsquo; recommendations, and I&rsquo;m proud that I came up with something that pretty closely matches some of the <a href="https://io7m.com/documents/udp-reliable/">recommendations</a> I found afterward. Here&rsquo;s what my initial solution looks like:</p>
{% image preview_img_src, preview_img_alt %}
<p>We chunk up the data, sending each chunk over to the front end. Each packet contains its chunk of data, plus all of the metadata necessary to reconstruct the data. Upon receipt, the front end sends back an ACK (acknowledge) message with the sequence number of the chunk it just received. When Rack receives an ACK, it checks to see whether all chunks have been received, and proceeeds to the success state if so. After the initial send, Rack also sets up a delayed action to check for un-ACK&rsquo;d chunks and resend them. If any chunk has been sent more than a configurable number of times, it is considered failed and the entire process proceeds to the failed state. In the diagram, a failure and a success are treated the same way: dispose of the data and move on. In reality, we might want to retry from the beginning, notify the user, and/or tell the front end to discard the partial data.</p>
{% yt "https://www.youtube.com/embed/gg5EPXSrBWk?si=4nZI5GpWem5TRnQb" %}
<p>Initially, we send over the dimensions of the model. That's the shape change you see at the beginning of the video. From there out, the chunks are transferring. This particular texture is 820,800 bytes (about 802k, a little under a megabyte), and sends in 744 chunks. It&rsquo;s pretty slow! 11.61 seconds. I&rsquo;m sure there is some optimization to be done for some minor gains there, but next time we&rsquo;ll take a look at compressing that data to see if we can't improve the performance more significantly.</p>
